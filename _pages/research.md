---
layout: archive
title: "Research Vision"
permalink: /research/
author_profile: true
redirect_from:
  - /resume
---
<!-- 
**TL;DR**: I study programmers of all kinds and build programming systems for them. One direction I’m exploring is how to make communication of thoughts more effective in programming environments. Related to this, I also wonder if we can build more active programming environments that not only actively provide programming help but also capture users’ high level ideas.

I have been studying and building live programming environments for various contexts, including introductory programming education and debugging. I found that … TODO
Recently I have observing how people use Jupyter notebooks for their day-to-day tasks. I found that… TODO

From the findings, I’m also exploring ideas for new notebook interfaces that better support their work and creativity. -->



**Effective programming systems are built upon a solid understanding of both the user needs and how programming affects their work.**
Programming systems (languages, interfaces, assistants) are ubiquitous, yet the design of most of them is still _technology-first_, requiring users to adapt their behavior to the affordances of the tool.
My first research agenda contributes **theories** of how people---especially novices and end-users---use programming for their day-to-day work to drive the design of user-centered programming systems.
To construct the theories, I apply one of the following HCI and social science approaches: interviews, contextual inquiry, in-lab studies, web-based controlled experiments, workshops, field observations, and grounded theory. 
<br/>
> My [recent work](/projects/) shows how live programming affects student learning, debugging GUI applications, and validating AI-generated code.
Currently, I am conducting a grounded theory study on the use of Jupyter notebooks for day-to-day work across various disciplines.



**Code is the low-level representation of one's higher-level ideas. Programming interfaces should let users not only write code but also stay in sync with their ideas.**
Existing programming interfaces don't quite support interacting with programs from different levels of abstractions, let alone showing the correspondence between levels. 
In other words, programmers could easily get lost in the low-level details of code and lose track of the high-level ideas the code intend to convey. 
My second research agenda builds **programming interfaces** as effective medium for communication.
> I am currently designing Jupyter notebook interfaces that always make notebook narratives clear while aligning the narratives to the notebook content, including code, output, and textual remarks.



**Programming assistants should help users at the right time with the right amount of help, _actively_.** 
Existing programming assistants are either _passive_, providing help only upon request, or _arbitraryly active_, always trying to help and inducing distractions. 
My third research agenda explores **programming assistants** that imply user workflow and actively provide appropriate help.
> My [recent work](/projects/) confirms that different stages of debugging calls for different levels of live programming. My ongoing work aims to derive a model of how users perform different tasks in Jupyter notebooks. I hope to design active notebook assistants based on such a model.



<!-- 

I design and develop two kinds of programming systems: _programming environments_ and _programming assistants_. Programming _environments_ enable reading and editing computer programs and the narratives they imply. 


I define programming assistants as the following: they show the ground truths of program behavior and suggest edits to code, providing understandable information that supports creativity and productivity. Programming assistants with a technology-first design can lead to usability problems and cognitive burdens, requiring the user to adapt their behavior to the tool. How do we design _usable_ programming assistants?
<!-- My current research _vision_ is the following: I hope to improve *human <-> human communication*, the main media of which are computers, specifically programming tools. Such communication can be subdivided into two categories, each coming with questions I aim to address: -->

<!-- 1. **Tool Designer-to-User Communication.** How should the designer of a programming tool (languages, interfaces, etc.) effectively communicate their design intent and the capabilities of the tool to the user, so that the tool is learnable and usable? What needs to be done so that the users' needs are taken into consideration during the design and development of the tool?

2. **Programmer-to-Programmer Communication.** What needs to be done in a programming tool such that it helps a programmer understand code written by the others (including machines)? -->
<!-- 1. **Self-to-Self Communication.** What programming aids can be developed to help the programmer correctly reason about the program behavior, assiting them with refining their mental model? How can one receive aids in understanding code they wrote a while ago? -->

<!-- 2. **Self-to-Other Communication.** How do we help programmers communicate their thought processes more effectively with collaborators, synchronously and asynchronously? What meta-data of cognitive processes can be embedded in programming languages and interfaces? -->

<!-- 
To that end, I adopt the **human-centered** approach to design programming assistants: 
- I use evidence from cognitive science and empirical investigations to derive the design space of a programming tool; and
- I work with potential users of a programming tool to refine the design space and iterate on existing designs.  -->
